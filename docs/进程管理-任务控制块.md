### 任务控制块

进程是操作系统中资源分配的基本单位。每个进程都有自己独立的地址空间和资源，如内存、文件描述符等。线程是操作系统中CPU调度的基本单位。线程共享所在进程的地址空间和资源，但有独立的执行上下文。

在调研其他队的设计时我们发现，很多队都将进程和线程分开设计，分别使用Process和Thread结构体表示。但其实POSIX规范中，并没有严格地区分进程和线程，而是通过一组统一的API来操作任务，例如`sys_clone`系统调用通过不同的 `flags` 组合创建共享不同资源的新任务，因此进程和线程的创建本质上是类似的。统一使用 `Task` 结构体，可以通过标志位决定任务的具体属性，而不需要区分进程结构体和线程结构体。比如，设置 `CLONE_VM` 标志位时，新任务共享父任务的地址空间，这可以通过 `Task` 结构体中的 `memory_space` 字段来实现共享。同样，设置 `CLONE_THREAD` 标志位时，新任务加入父任务的线程组，这可以通过 `Task` 结构体中的 `ThreadGroup` 字段来实现管理。

#### Task结构体设计

基于上述分析，我们对进程和线程统一使用`Task`结构体表示，其具体设计如下：

```rust
pub struct Task {
    // Immutable
    /// Task identifier handle.
    tid: TidHandle,
    /// Weak reference to the leader task. `None` if this task is the leader.
    leader: Option<Weak<Task>>,
    /// Indicates if the task is the leader of its thread group.
    is_leader: bool,

    // Mutable
    /// Indicates if the task is a zombie. Protected by a spin lock due to potential access by other tasks.
    state: SpinNoIrqLock<TaskState>,
    /// The address space of the process.
    memory_space: Shared<MemorySpace>,
    /// Map of start address of shared memory areas to their keys in the shared memory manager.
    shm_ids: Shared<BTreeMap<VirtAddr, usize>>,
    /// Parent task.
    parent: Shared<Option<Weak<Task>>>,
    /// Child tasks.
    children: Shared<BTreeMap<Tid, Arc<Task>>>,
    /// Exit code of the task.
    exit_code: AtomicI32,
    /// Trap context for the task.
    trap_context: SyncUnsafeCell<TrapContext>,
    /// Waker to add the task back to the scheduler.
    waker: SyncUnsafeCell<Option<Waker>>,
    /// Thread group containing this task.
    thread_group: Shared<ThreadGroup>,
    /// File descriptor table.
    fd_table: Shared<FdTable>,
    /// Current working directory.
    cwd: Shared<Arc<dyn Dentry>>,
    /// Pending signals for the task.
    sig_pending: SpinNoIrqLock<SigPending>,
    /// Signal handlers. Shared if `CLONE_SIGHAND` flag is set or among threads in the same group.
    sig_handlers: Shared<SigHandlers>,
    /// Signal mask indicating which signals are blocked.
    sig_mask: SyncUnsafeCell<SigSet>,
    /// Optional signal stack for the task, settable via `sys_signalstack`.
    sig_stack: SyncUnsafeCell<Option<SignalStack>>,
    /// Pointer to the user context for signal handling.
    sig_ucontext_ptr: AtomicUsize,
    /// Statistics for task execution times.
    time_stat: SyncUnsafeCell<TaskTimeStat>,
    /// Interval timers for the task.
    itimers: Shared<[ITimer; 3]>,
    /// Futexes used by the task.
    futexes: Shared<Futexes>,
    /// Address to store the task identifier.
    tid_address: SyncUnsafeCell<TidAddress>,
    /// Allowed CPUs for the task.
    cpus_allowed: SyncUnsafeCell<CpuMask>,
}
```

下面介绍一下Task结构体各个字段的含义。

首先Task结构体被大致划分为不可变（Immutable）和可变（Mutable）两部分：

- **不可变部分**：不可变字段在任务创建后不会改变，因此可以保证数据的一致性。这些字段通常包括任务的基本标识信息，如 `tid`（任务ID）和 `is_leader`（是否为领导者）。由于这些字段不会改变，多线程环境下访问这些字段时不需要加锁，可以提高访问效率和安全性。

| 字段名      | 含义                                                    |
| ----------- | ------------------------------------------------------- |
| `tid`       | 任务的唯一标识符（任务ID）。                            |
| `leader`    | 对领导者任务的弱引用。如果该任务是领导者，则为 `None`。 |
| `is_leader` | 标识任务是否是线程组的领导者。                          |

- **可变部分**：可变字段涉及任务的状态和资源管理，如 `state`（任务状态）、`memory_space`（内存空间）和 `children`（子任务）。这些字段在任务的生命周期内可能会改变，需要使用锁机制来保证线程安全。

| 字段名             | 含义                                                                                            |
| ------------------ | ----------------------------------------------------------------------------------------------- |
| `state`            | 任务的当前状态（例如，运行中、等待中、僵尸状态等），由自旋锁保护以确保线程安全。                |
| `memory_space`     | 任务的地址空间。                                                                                |
| `shm_ids`          | 共享内存区域起始地址到共享内存管理器中的键的映射。                                              |
| `parent`           | 父任务。                                                                                        |
| `children`         | 子任务。                                                                                        |
| `exit_code`        | 任务的退出代码。                                                                                |
| `trap_context`     | 任务的陷阱上下文。                                                                              |
| `waker`            | 用于将任务重新添加到调度器的唤醒器。                                                            |
| `thread_group`     | 包含该任务的线程组。                                                                            |
| `fd_table`         | 文件描述符表。                                                                                  |
| `cwd`              | 当前工作目录。                                                                                  |
| `sig_pending`      | 任务的挂起信号。                                                                                |
| `sig_handlers`     | 信号处理程序表。如果设置了 `CLONE_SIGHAND` 标志或者任务在同一线程组中，则这些处理程序是共享的。 |
| `sig_mask`         | 信号屏蔽，用于指示哪些信号被阻塞。                                                              |
| `sig_stack`        | 任务的可选信号栈，通过 `sys_signalstack` 设置。                                                 |
| `sig_ucontext_ptr` | 信号处理的用户上下文指针。                                                                      |
| `time_stat`        | 任务执行时间的统计信息。                                                                        |
| `itimers`          | 任务的间隔定时器。                                                                              |
| `futexes`          | 任务使用的轻量级锁（futexes）。                                                                 |
| `tid_address`      | 存储任务标识符的地址。                                                                          |
| `cpus_allowed`     | 任务允许运行的CPU集合。                                                                         |

对于Task的可变部分，我们也进行了巧妙设计，调研其他队时我们发现，很多队都用了`Inner`结构体存储可变字段，并在外面加上自旋锁的方式，此种方式虽然能在并发时保证数据的安全性，但是用一把大锁来锁定可变字段并不高效。因此，我们使用`SyncUnsafeCell`和`Shared<T>`(即`Arc<SpinNoIrqLock<T>>`)对可变字段进行包裹，实现Rust的内部可变性：

- `SyncUnsafeCell<T>`：对于线程独有的字段使用SyncUnsafeCell包裹

  `SyncUnsafeCell` 是一种可以在线程间共享的 `UnsafeCell`。虽然 `UnsafeCell` 本身不实现 `Sync`，`SyncUnsafeCell` 可以在 `T` 实现 `Sync` 的情况下实现 `Sync`。这使得它可以在多线程环境中共享，并且仍然允许内部可变性。

- `Arc<SpinNoIrqLock<T>>`：对同一进程内线程共享的字段使用`Arc<SpinNoIrqLock<T>>`包裹`SpinNoIrqLock` 是一种自旋锁，适用于短时间的锁定操作。它不会引发中断，因此适用于操作系统内核中需要快速响应的部分。使用 `SpinNoIrqLock` 包裹的字段可以在并发访问时进行保护，避免数据竞争和不一致。`Arc`（原子引用计数）允许多个所有者共享同一个数据，同时维护共享数据的引用计数，以确保数据在最后一个引用被丢弃时才被释放。

在 `Task` 结构体中使用 `Shared<T>` 和 `SyncUnsafeCell<T>` 包裹可变字段，可以有效地实现内部可变性和细粒度锁定。这种设计允许在多个任务之间安全地共享和修改数据，提高了系统的并发性和性能，同时保证了线程安全性。通过这些机制，操作系统能够更加高效地管理任务和资源。

#### `ThreadGroup`与进程线程的关系

对进程和线程用`Task`结构体进行统一表示，`ThreadGroup` 结构体用于管理属于同一进程的线程组。通过将多个线程归属于一个 `ThreadGroup`，可以方便地管理和调度同一进程中的所有线程。`Task` 结构体和 `ThreadGroup` 结构体的结合，实现了统一的进程和线程管理。

```rust
pub struct ThreadGroup {
    members: BTreeMap<Tid, Weak<Task>>,
}
```

`ThreadGroup` 结构体包含一个 `BTreeMap`，该映射将线程的唯一标识符 (`Tid`) 映射到对 `Task` 的弱引用 (`Weak<Task>`)。当新创建一个进程时，ThreadGroup仅有进程本身这个成员，Task的`is_leader`字段设为`True`。当`sys_clone`设置 `CLONE_THREAD` 标志位时，将新创建的`Task`添加入`ThreadGroup`，新`Task`的`is_leader`字段设为`False`

#### 任务的状态

在调研其他操作系统时，我们发现部分往届作品如Titanix只是简单区分了`Running`和`Zombie`状态，并不支持当`SIGSTOP`信号到来时进程暂停执行，此外，任务在阻塞的过程中能否被信号打断也支持得并不是很好，Linux关于信号的手册中有提到，部分系统调用在阻塞等待的过程中可以被信号打断停止执行，返回`EINTR`错误，如果打断系统调用的信号的`flag`标志中含有`SA_RESTART`可以重启系统调用。基于以上考虑，我们将Task的状态分为以下五种：

| 状态              | 含义                                                                                                               |
| ----------------- | ------------------------------------------------------------------------------------------------------------------ |
| `Running`         | 正在运行或准备运行的任务。此状态下，任务占用 CPU，执行其代码。                                                     |
| `Zombie`          | 任务已终止，但其进程控制块 (PCB) 仍然存在，以便父进程可以读取其退出状态。                                          |
| `Stopped`         | 任务已停止运行，通常是由于接收到停止信号（如 `SIGSTOP`）。可以通过特定信号（如 `SIGCONT`）恢复运行。               |
| `Interruptable`   | 任务处于可中断的等待状态，等待某个事件（如 I/O 操作完成或资源释放）。此状态下，任务可以被信号中断并唤醒。          |
| `UnInterruptable` | 任务处于不可中断的等待状态，等待某个事件的发生。此状态下，任务不会被信号中断，以确保某些关键操作的完整性和原子性。 |

进程间的状态转换情况如下：

1. **Running <-> Interruptable**：当任务需要等待某个事件时，从 `Running` 转换到 `Interruptable` 状态。例如，在实现`sys_wait4`系统调用时，Task调用`suspend_now()`将自己从任务调度队列中移除，进入`Interruptable`状态，即可以被信号中断，如果是等待的子进程退出，返回子进程的`pid`，如果是被信号中断，返回`EINTR`错误。之后从`Interruptable`状态恢复为`Running`
2. **Running< -> UnInterruptable**
   - 当任务需要等待某个关键事件且不希望被信号中断时，从 `Running` 转换到 `UnInterruptable` 状态。当等待的事件发生时，恢复到 `Running` 状态
3. **Running -> Zombie**
   - 当任务执行结束并退出时，从 `Running` 转换到 `Zombie` 状态。
4. **Running -> Stopped**
   - 当任务接收到停止信号（如 `SIGSTOP`）时，从 `Running` 转换到 `Stopped` 状态。
5. **Stopped -> Running**
   - 当任务接收到继续信号（如 `SIGCONT`）时，从 `Stopped` 转换回 `Running` 状态。
