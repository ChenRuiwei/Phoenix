# 任务调度

## 为什么选择无栈协程

协程是一种比线程更加轻量级的并发单位，允许在执行过程中挂起并稍后恢复，从而使得单个线程可以处理多个任务。无栈协程和有栈协程的主要区别在于它们的上下文管理方式。

- **有栈协程（Stackful Coroutine）**：每个协程都有自己的栈，这样可以在协程内部随时进行函数调用和上下文切换，在大规模并发时会带来较大的内存开销。在RISC-V架构的操作系统中，有栈协程需要在栈中保存`s0-s11`、`ra`、`sp`这14个寄存器。
- **无栈协程（Stackless Coroutine）**：协程没有独立的栈，而是依赖于状态机来管理上下文，每次协程挂起时需要保存执行的状态和位置，下次恢复时从该位置继续执行。无栈协程非常轻量，适合大规模并发。但是不适合深度嵌套的函数调用，适合用在状态转移和事件驱动的场景中。

在操作系统中，每一个线程都有其上下文环境，当发生任务调度时，任务切换其实就是上下文切换。任务时由内核来管理和调度的，任务的切换必须发生在内核态。

在Linux系统中，一个进程的上下文可以分为以下三个部分：

1. 用户级上下文：包括了进程在用户态下的运行状态和资源。如用户堆栈、全局变量和静态变量等等
2. 寄存器上下文：如通用寄存器、栈指针
3. 系统级上下文：如进程控制块、内核栈、页表

当Linux发生进程调度时，必须对上面的全部信息进行切换。通过调用函数的方法(Linux内核中switch_to函数)进行上下文切换。

但是，Phoenix使用无栈协程架构，所有任务共享同一个内核栈，任务调度时不需要切换内核栈，因此调度的开销实际上小于Linux。Phoenix的任务切换发生在`await`处，当`poll`轮询返回`pending`时不断退出本层`async`函数返回到上一层的`async`函数，直到回到调度器，接着调度器调度到下一个任务，并根据堆上的信息重新生成新任务的函数调用栈，来到上次该任务await的地方继续`poll`轮询。

我们选择无栈协程，除了其任务切换开销小以外，很大一部分原因也与Rust语言本身的异步编程模型有关。

Rust的所有权系统通过编译时检查保证内存安全，防止数据竞争、空指针和悬挂指针等问题。Rust的所有权和借用检查，能够更好地保证协程在并发执行时的安全性，确保资源在使用后会被正确释放，更加高效地利用系统资源。

另外，Rust内置的异步编程模型通过`async`和`await`关键字支持无栈协程，这种语法糖使得编写和使用无栈协程变得更加简洁和直观。每个`async`函数在编译时会被转换为状态机，自动管理状态的保存和恢复。无栈协程符合Rust所追求的"零成本抽象"，状态机的转换和上下文切换在编译期确定，运行时开销极小。在敏捷开发过程中，这种语法糖能极大提高操作系统的开发效率。

此外，Rust活跃的社区和丰富的生态系统也提供了大量用于异步编程和协程的库和工具。由于我们在无标准库`no-std`的环境下开发，因此使用了可以不依赖标准库的`async-task`提供的异步运行时。

## Rust无栈协程原理

### 将异步函数编译成状态机

2019年底Rust推出了支持异步编程的`async` 和 `await` 关键字，极大地简化了异步函数的定义和调用，并在无栈协程调度中发挥了重要作用。

- `async` 关键字用于定义异步函数、异步块或异步闭包。当使用 `async` 标记一个函数时，该函数不再同步返回结果，而是返回一个实现了 `Future` trait 的对象。在编译时，带有 `async` 关键字的代码会被转换为一个状态机。这个状态机会在每个 `await` 点保存当前状态，并在未来的某个时刻恢复执行。
- `await` 关键字用于等待一个实现了 `Future` trait 的对象完成，并获取其结果。当执行到 `await` 时，如果 `Future` 尚未完成，当前任务会挂起，并允许其它任务继续执行。每当 `Future` 完成时，使用 `await` 的代码会从挂起点恢复执行，状态机会从之前保存的状态继续运行。

下面这个例子演示了这两个关键字的使用：

```rust
async fn async_function() {
    println!("First part of the function");
    async_operation().await;
    println!("Second part of the function");
}

async fn async_operation() {
    // 模拟异步操作
    println!("Performing async operation");
}

```

Rust编译器会将上面这段代码编译成一个实现`Future` trait的状态机。这个状态机记录了函数执行的当前位置和需要恢复的状态:

```rust
enum AsyncState {
    FirstPart,
    AwaitingOperation,
    SecondPart,
    Done,
}

struct AsyncFunction {
    state: AsyncState,
}

impl AsyncFunction {
    fn new() -> Self {
        AsyncFunction {
            state: AsyncState::FirstPart,
        }
    }
}

impl Future for AsyncFunction {
    type Output = ();

    fn poll(mut self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Self::Output> {
        loop {
            match self.state {
                AsyncState::FirstPart => {
                    println!("First part of the function");
                    self.state = AsyncState::AwaitingOperation;
                }
                AsyncState::AwaitingOperation => {
                    println!("Performing async operation");
                    self.state = AsyncState::SecondPart;
                    return Poll::Pending;
                }
                AsyncState::SecondPart => {
                    println!("Second part of the function");
                    self.state = AsyncState::Done;
                }
                AsyncState::Done => {
                    return Poll::Ready(());
                }
            }
        }
    }
}
```

上面这段代码涉及到如下几个关键的概念：

- **`Future` Trait**：我们可以将`Future` 理解为一个异步计算的抽象，它的 `poll` 方法会尝试推进计算。`Future` trait 类似于一个任务的描述，告诉你这个任务将在未来完成，并且可以查询其状态。

- **`Poll` 枚举**：表示 `Future` 的当前状态（注意`Poll`枚举不是`poll`方法，两者是两个概念）：

  - `Poll::Pending`：异步操作尚未完成，需要等待。

  - `Poll::Ready(T)`：异步操作已经完成，可以返回结果。

- **`Pin`**：`poll` 方法的 `self` 参数被包裹在 `Pin<&mut Self>` 中，确保 `AsyncFunction` 的内存位置固定，不会被移动，从而保证安全。

- **`Context`** :包含了执行 `Future` 所需的上下文信息，例如 `Waker`，它允许 `Future` 在准备好继续执行时通知执行器。`Context` 使得 `Future` 可以与外部世界交互，知道何时需要继续执行。

### Executor 和 Reactor 

Executor（执行器）是一个运行时组件，它负责管理和调度异步任务。Executor的主要职责包括：

1. **运行Futures**：Executor会调用Futures的`poll`方法来推进它们的执行。
2. **任务队列**：Executor维护一个任务队列，存放所有准备好执行的任务。
3. **循环调度**：Executor在循环中轮询任务队列，逐个执行任务。当任务返回`Poll::Ready`时，表示任务已经完成；当返回`Poll::Pending`时，表示任务尚未完成，需要等待某些条件。

Reactor（反应器）是另一个运行时组件，负责管理和处理异步I/O操作或其他需要等待的事件。Reactor的主要职责包括：

1. **等待事件**：Reactor等待异步操作的完成，例如网络I/O、文件I/O、计时器等。
2. **唤醒任务**：当异步操作完成时，Reactor会唤醒相应的任务，并将它们重新放入Executor的任务队列，以便再次执行。

## 任务调度队列与执行器

为了存储待执行的协程任务，Phoenix定义了一个全局的任务队列`TASK_QUEUE`，各个CPU可以从该任务队列中获取任务执行。`TaskQueue`是一个使用 `SpinNoIrqLock` 保护一个双端队列（`VecDeque`），Runnable为可调度的任务：

```rust
struct TaskQueue {
    queue: SpinNoIrqLock<VecDeque<Runnable>>,
}
```

`spawn` 函数用于创建并启动一个新的异步任务。它接收一个实现了 `Future` 的对象，并将其转换为一个可以调度和执行的任务并添加到任务队列中。`async_task`是Phoenix选择的异步运行时库。

```rust
pub fn spawn<F>(future: F) -> (Runnable, Task<F::Output>)
where
    F: Future + Send + 'static,
    F::Output: Send + 'static,
{
    let schedule = move |runnable: Runnable, info: ScheduleInfo| {
        if info.woken_while_running {
            // i.e `yield_now()`
            TASK_QUEUE.push(runnable);
        } else {
            // i.e. woken up by some signal
            TASK_QUEUE.push_preempt(runnable);
        }
    };
    async_task::spawn(future, WithInfo(schedule))
}
```

任务的调度策略如下：

- 如果任务在运行时被唤醒（`woken_while_running`），将任务放到队列尾部，按照先入先出的顺序执行。。这种情况通常发生在任务调用`yield_now()`主动让出处理器时。
- 如果任务在睡眠中被唤醒，将任务放到队列头部，以确保优先执行。这种情况通常发生在任务已经休眠正在等待某个事件，此时等待的事件发生时将该任务唤醒。也可能发生在任务在处于`Interruptable`状态，此时收到了一个未阻塞的信号并且触发了sighandler函数，将任务唤醒

`run_until_idle` 函数负责从任务队列中取出并执行任务，直到队列为空。Phoenix支持多核并发，每一个CPU核心都在一个永不停止的loop循环中持续调用该函数

```rust
pub fn run_until_idle() {
    while let Some(task) = TASK_QUEUE.fetch() {
        task.run();
    }
}
```

## 异步任务上下文切换

每一个任务都有独立的上下文，在进行上下文切换时，Phoenix需要切换任务控制块、sum计数器（用来维护内核态对用户内存的访问限制）、页表。

>`SUM` 标志位的主要作用是控制在内核态（特权级S模式或M模式）下，是否允许内核访问用户态（U模式）的内存。Phoenix在内核态处理系统调用访问用户态指针时需要维护sum_cnt计数器，当计数器大于0，SUM标志位为1，此时内核可以安全地读取或写入用户态缓冲区。内核完成对用户态缓冲区的操作后，sum_cnt计数器减一。当减到0时需要恢复`SUM`位为0以避免意外访问用户态内存。

实际上，上下文的切换可以与Rust异步无栈协程完美结合。在每一个用户异步任务的最外层都套了一层`UserTaskFuture`:

```rust
pub struct UserTaskFuture<F: Future + Send + 'static> {
    task: Arc<Task>,
    env: EnvContext,
    future: F,
}

impl<F: Future + Send + 'static> Future for UserTaskFuture<F> {
    type Output = F::Output;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        let this = unsafe { self.get_unchecked_mut() };
        let hart = hart::local_hart();
        hart.enter_user_task_switch(&mut this.task, &mut this.env);
        let ret = unsafe { Pin::new_unchecked(&mut this.future).poll(cx) };
        hart.leave_user_task_switch(&mut this.env);
        ret
    }
}
```

`UserTaskFuture` 的`EnvContext`字段存放了sum计数器，`task`字段存储了任务控制块和页表。`enter_user_task_switch`函数将当前CPU的上下文切换为即将执行的`task`，执行完毕后，`leave_user_task_switch`则将页表切换回内核页表，任务调度器将会轮询下一个UserTaskFuture。注意切换任务的时候需要关中断，否则可能产生死锁。

`UserTaskFuture`中的`future`字段对于每一个任务而言都是同一个异步函数`task_loop`，也就是在`task`的生命周期内不断进行返回用户态、陷入内核态、信号处理等过程，直到`task`结束，状态变为`Zombie`后退出循环，交由`do_exit`函数进行处理。

