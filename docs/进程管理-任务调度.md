## 任务调度

### 为什么选择无栈协程

协程是一种比线程更加轻量级的并发单位。协程允许在执行过程中挂起并稍后恢复，从而使得单个线程可以处理多个任务。无栈协程和有栈协程的主要区别在于它们的上下文管理方式。

- **有栈协程（Stackful Coroutine）**：每个协程都有自己的栈，这样可以在协程内部随时进行函数调用和上下文切换，在大规模并发时会带来较大的内存开销
- **无栈协程（Stackless Coroutine）**：协程没有独立的栈，而是依赖于状态机来管理上下文，每次协程挂起时需要保存执行的状态和位置，下次恢复时从该位置继续执行。无栈协程非常轻量，适合大规模并发。但是不适合深度嵌套的函数调用，适合用在状态转移和事件驱动的场景中。

经典的Linux操作系统采用的是有栈协程调度，效率依旧很高，但是之所以我们选择无栈协程，除了其切换开销小以外，很大一部分原因也与Rust语言本身的异步编程模型有关。

Rust的所有权系统通过编译时检查保证内存安全，防止数据竞争、空指针和悬挂指针等问题。结合Rust的所有权和借用检查，能够更好地保证协程在并发执行时的安全性，确保资源在使用后会被正确释放，更加高效地利用系统资源。

另外，Rust内置的异步编程模型通过`async`和`await`关键字支持无栈协程，这种语法糖使得编写和使用无栈协程变得更加简洁和直观。每个`async`函数在编译时会被转换为状态机，自动管理状态的保存和恢复。无栈协程符合Rust所追求的"零成本抽象"，状态机的转换和上下文切换在编译期确定，运行时开销极小。在敏捷开发过程中，这种语法糖能极大提高操作系统的开发效率。

此外，Rust活跃的社区和丰富的生态系统也提供了大量用于异步编程和协程的库和工具。我们就使用了`async-task`库提供的异步运行时。

### 无栈协程原理

TODO：

