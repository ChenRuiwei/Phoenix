# 中断与异常

在Linux操作系统中，Linux内核使用了Page Table Isolation (PTI)机制，内核态和用户态的页表相互独立，当系统运行在用户态时，仅使用用户页表，这个页表只包含极少量必须的内核数据，如用于进入和退出内核的函数和中断描述符表（IDT）。当系统进入内核态（通过系统调用、中断或异常）时，切换到完整的内核页表。这种设计的主要优点包括：

1. **提高安全性**：独立的页表可以有效防止侧信道攻击，使得用户态程序无法访问敏感的内核数据。
2. **保护内核空间**：即使攻击者能够突破用户态的防线，也无法直接访问或利用内核地址空间。

然而，这种设计也带来了额外的开销：

1. **内存使用增加**：每个进程需要维护两套页表，增加了内存消耗。
2. **性能开销**：每次从用户态切换到内核态（或反之）时，都需要切换页表，这涉及到刷新TLB（Translation Lookaside Buffer），增加了系统调用和中断处理的成本

Phoenix采用了用户态与内核态共用一个页表的策略，共用一个页表避免了在用户态和内核态之间切换时刷新TLB的开销，从而提升了系统性能，并且简化了页表管理的实现和维护。

在Phoenix中，Task的生命周期就是在执行下面这个函数：

```rust
pub async fn task_loop(task: Arc<Task>) {
    *task.waker() = Some(take_waker().await);
    loop {
        trap::user_trap::trap_return(&task);
        match task.state() {
            Zombie => break,
            Stopped => suspend_now().await,
            _ => {}
        }
        trap::user_trap::trap_handler(&task).await;
        match task.state() {
            Zombie => break,
            Stopped => suspend_now().await,
            _ => {}
        }
        task.update_itimers();
        do_signal().expect("do signal error");
    }
    task.do_exit();
}
```

即Task先创建，然后执行`trap_return`返回用户态、陷入内核态由`trap_handler`处理中断和异常、`do_signal`执行信号处理函数，当Task被设置为`Zombie`状态时，回收部分资源，在`Wait4`系统调用时彻底回收Task资源。

在Phoenix的内核态用户态切换中，`TrapContext` 是一个关键的数据结构，用于保存从用户态切换到内核态，以及从内核态切换回用户态时需要保存和恢复的上下文信息。这个结构体的设计保证了用户态和内核态之间的切换能够正确地进行，不会丢失任何重要的状态信息。

```rust
pub struct TrapContext {
    // User to kernel should save:
    pub user_x: [usize; 32],
    pub sstatus: Sstatus, // 32
    pub sepc: usize, // 33
    // Kernel to user should save:
    pub kernel_sp: usize, // 34
    pub kernel_ra: usize, // 35
    pub kernel_s: [usize; 12], // 36 - 47
    pub kernel_fp: usize, // 48
    pub kernel_tp: usize, // 49
    pub user_fx: UserFloatContext,
}
```

| 字段名称                    | 说明                                                         | 用户态到内核态保存 | 内核态到用户态保存 |
| --------------------------- | ------------------------------------------------------------ | ------------------ | ------------------ |
| `user_x: [usize; 32]`       | 保存用户态的通用寄存器，包含了RISC-V架构中的所有32个寄存器的值。 | 是                 | 否                 |
| `sstatus: Sstatus`          | 保存状态寄存器（Status Register）的值，这个寄存器包含了用户态和内核态的各种状态标志。 | 是                 | 否                 |
| `sepc: usize`               | 保存异常程序计数器（Exception Program Counter），即发生异常或中断时的用户程序的PC值。 | 是                 | 否                 |
| `kernel_sp: usize`          | 保存内核态的栈指针，用于在返回用户态时恢复内核栈的状态。     | 否                 | 是                 |
| `kernel_ra: usize`          | 保存内核态的返回地址寄存器（Return Address Register），用于在返回用户态时恢复内核的返回地址。 | 否                 | 是                 |
| `kernel_s: [usize; 12]`     | 保存内核态的保存寄存器（Saved Registers），这些寄存器在上下文切换时需要保存和恢复。 | 否                 | 是                 |
| `kernel_fp: usize`          | 保存内核态的帧指针（Frame Pointer），用于在返回用户态时恢复内核的帧指针。 | 否                 | 是                 |
| `kernel_tp: usize`          | 保存内核态的硬件线程指针（Hardware Thread Pointer），用于在返回用户态时恢复内核的线程指针。 | 否                 | 是                 |
| `user_fx: UserFloatContext` | 保存用户态的浮点寄存器上下文，包括所有的浮点寄存器以及相关的状态标志。 | 是                 | 否                 |

## 内核态$\rightarrow$用户态

在Phoenix中，从内核态切换到用户态发生在以下两种情况：

1. Task从ELF文件中构建出来时
2. 因为内核态的系统调用、中断或异常处理完成重新返回用户态时

通常情况下，在返回用户态之前需要执行信号处理函数，不过在第一种情况中，Task刚被创建时还没有收到信号，因此`loop`循环第一行是直接`trap_return`，将`do_signal`放在`loop`的结尾。

```rust
pub fn trap_return(task: &Arc<Task>) {
    unsafe {
        disable_interrupt();
        set_user_trap()
    };
    task.time_stat().record_trap_return();
    unsafe {
        __return_to_user(task.trap_context_mut());
    }
    task.time_stat().record_trap();
}
```

在返回用户态之前，为了保证上下文切换的原子性，先禁用中断以防止在切换过程中发生新的中断。调用`set_user_trap()`函数设置陷阱处理函数，以确保下一次从用户态陷入内核态时能够正确处理。使用`__return_to_user`汇编函数，将之前存储的用户寄存器恢复。

在返回用户态时，将`TrapContext`的地址存储在`sscratch`寄存器中，`a0`寄存器指向`TrapContext`。再保存内核态的寄存器，切换栈指针并恢复状态寄存器、通用寄存器、用户态指针，最后使用`sret`指令返回用户态。

## 用户态$\rightarrow$内核态

在Phoenix中，从用户态切换到内核态发生在以下三种情况：

1. **系统调用**：用户程序请求内核服务。
2. **中断**：硬件设备需要处理。
3. **异常**：用户程序执行非法操作。

当从用户态陷入内核态时，会进入`__trap_from_user`标签定义的代码。这段汇编代码的作用是保存用户态的上下文，并准备好内核态的环境。接着进入`trap_handler`函数根据不同的陷阱类型进行处理。

`trap_handler`函数会获取任务的陷阱上下文、读取`stval`、`scause`、`sepc`寄存器的值，得到引起陷阱的虚拟地址、引起陷阱的原因、引起陷阱的指令地址。如果是系统调用则依据无栈协程架构异步执行系统调用，如果是页面错误则调用`handle_page_fault`函数，如果是非法指令则终止task，如果是定时器中断则让出处理器等待下次调度。

## 内核态$\rightarrow$内核态

在MIT的xv6操作系统与清华大学的rCore-Tutorial操作系统中，并不支持内核态的中断，这会导致内核对部分中断的响应不及时，在rCore-Tutorial操作系统中甚至会直接Panic，

Phoenix允许嵌套中断，例如内核态在收到时钟中断时，或者在执行系统调用中遇到访存异常时，依然会对中断进行处理。

内核态发生中断时，Phoenix依次执行如下操作：

- **保存调用者保存寄存器**：在陷阱发生时，保存调用者保存的寄存器（`ra`, `t0-t6`, `a0-a7`）。
- **调用陷阱处理函数**：调用 `kernel_trap_handler` 处理陷阱。
- **恢复调用者保存寄存器**：在陷阱处理完成后，恢复之前保存的寄存器。
- **返回指令**：使用 `sret` 指令返回到陷阱发生前的执行点。

此外，在执行系统调用时会涉及到用户态指针的读写，Phoenix采取的是直接解引用用户态指针的方法提高系统调用的执行速度。但是用户态传入的指针可能指向了非法内存，此时对非法内存的访问也会造成内核态的中断。为此，Phoenix在读写用户态指针时，将中断处理函数单独设置为`__user_rw_trap_vector`对内存读写产生的中断进行单独处理。